---
layout: post
title: less-programming-more-skill

---
I just picked up a copy of [Programmers at Work](http://www.amazon.com/gp/product/1556152116?ie=UTF8&tag=mob-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1556152116)![](http://www.assoc-amazon.com/e/ir?t=mob-20&l=as2&o=1&a=1556152116) \(disclosure: that's a paid Amazon link\) and I've been looking forward to reading it. I've only read the Charles Simonyi chapter; I got distracted by other books and other things, but it's sitting there on my nightstand waiting.  
  
So it was pretty cool to see Jeff Atwood quote the book on his blog entry [about becoming a better programmer by not programming](http://www.codinghorror.com/blog/archives/000543.html). I agree with the quote:  


>   
_Does accumulating experience through the years necessarily make programming easier?_  
  
**Bill Gates**: No. I think after the first three or four years, it's pretty cast in concrete whether you're a good programmer or not. After a few more years, you may know more about managing large projects and personalities, but after three or four years, it's clear what you're going to be. There's no one at Microsoft who was just kind of mediocre for a couple of years, and then just out of the blue started optimizing everything in sight. I can talk to somebody about a program that he's written and know right away whether he's really a good programmer.   


  
And I definitely agree with this from Jeff:  


>   
You won't-- you cannot-- become a better programmer through sheer force of programming alone. You can only complement and enhance your existing programming skills by branching out. Learn about your users. Learn about the industry. Learn about your business.  


  
I think he limits it too much, though.  
  
The best thing I ever did for myself was walking away from programming, as best as I could, for 4 years. In 1998, after 3.5 years at Microsoft and 5 years of high-stress programming before that, I was burned out, unsure of what I wanted to do with my life, and fed up with the work I was doing. I cashed out my stock options, put all my belongings in my friend's basement, and set out to hike, bike, and finally get that college degree I'd always wanted.  
  
The day I quit, I started driving to LA. I hiked in Joshua Tree, then went to Canyonlands and hiked for days in the Maze, where I swear I was surrounded by the ghosts of the Anasazi. I flew back to Massachusetts, saw my parents, then took the train to northern Georgia and started hiking home on the Appalachian Trail. I didn't quite make it, but detoured to Washington DC for the 4th of July, hiked some more in Vermont, then went to Olympia for school.  
  
At school, I took classes in forest ecology, evolutionary biology, neuroscience, geography, linguistics, and so on. I learned a bunch, despite the hippies.  
  
Between classes and during breaks, I rode my bike in the mud of Olympia, augmented with road trips to the sandstone of Moab and the dust of Nevada. I met my wife, and during summer vacation, we rode our bikes from northern Montana to Wyoming; we saw bears, and almost got struck by lightning, and saw amazing views and played pool at every dive bar that would let a couple of smelly cyclists in.  
  
Through all of this, I missed programming. I dreamt about it, in good ways.  
  
I didn't miss the long hours or the stress, but I missed being surrounded by lots of really smart people, and sitting down in front of a computer to just crank out code. I did a little bit of contract work, and after a few years I joined a startup with some friends, then ended up back at Microsoft.  
  
Now, 9 years after trying to leave programming behind, I'm working on stuff that gets me as stoked as I was when I was 11 years old and learning Logo, or 13 years old and learning to do psychedelic animation with palette switching, or 16 years old and learning assembly language. There is **always** something new to learn -- always a new way of looking at a problem you've known about for a while, always a new problem to discover.  
  
But Jeff is saying something a little different than what I'm driving at, I think:  


>   
Passion for coding is a wonderful thing. But it's all too easy to mindlessly, reflexively entrench yourself deeper and deeper into a skill that you've already proven yourself more than capable at many times over. To truly become a better programmer, you have to to cultivate passion for everything else that goes on around the programming.  


  
Of course I agree: if you have profound knowledge of the cloud of problems around programming, of the higher level problems you're trying to solve, you'll do a better job programming. This is obvious, and explains why the best programs are always the ones programmers write for themselves, eg. emacs, Google, Visicalc, etc. And it conversely explains why so many programs are so uninspired, too: if you'll never use the feature you're writing, you're not going to imbue it with brilliance, because the brilliance will never occur to you.  
  
And beyond that, if you truly love the entire experience of programming -- not just the act of sitting in front of keyboard, but the planning, and the bug triage, and the promotion of your ideas -- of course you'll do a better job. And yes, this cloud takes some time to master, and for many programmers it's a huge barrier.  
  
But that stuff is necessary but insufficient. If you're gonna implement the killer features **you** want, you need the chops to bang 'em out. And if those killer features are also gonna be used by a million, or a hundred million, other people, you'd better have the chops to bang out that code rock-freakin'-solid. Those chops don't come in 3 years, as Bill Gates claims, and they don't come from the 97th percentile of programmers, as Jeff alludes:  


>   
Good developers are good at programming. Really good at programming. You might even say fanatically good. If they're anything like me, they've spent nearly every waking moment in front of a computer for most of their lives. And naturally, they get better at it over time. Competent software developers have already mastered the skill of programming, which puts them in a very select club. But if you're already in the 97th percentile for programming aptitude, what difference does a few more percentile points really make in the big scheme of things?  


  
The really killer code that's used to build the really killer features come from the programmers with a Z-score of 5 or 6, not 3. Being a natural will get you most of the way there, but unless you're a true prodigy, you need to continually refine your skills over many years. For most people, I think that cultivating expertise and interests outside the scope of programming helps this, as it does with any creative endeavor: as an analogy, if you want to write, read lots and write lots, but also **live** lots. For me, staying psyched about programming definitely requires lots of extrinsic inspiration; I'm a better programmer when I have time to ride my bike, and run, and play with my daughter, and laugh with my wife.  
  
Being an excellent programmer requires being excellent at the cloud of things directly related to programming -- dealing with people, anticipating problems, having vision about products and features -- of course it does, and of course you should cultivate that. Beyond that, I truly think it requires external stimulation; really, really not programming will let you recharge and be better at programming. I doubt this is limited to programming.  
  
_  
A human being should be able to change a diaper, plan an invasion, butcher a hog, conn a ship, design a building, write a sonnet, balance accounts, build a wall, set a bone, comfort the dying, take orders, give orders, cooperate, act alone, solve equations, analyze a new problem, pitch manure, program a computer, cook a tasty meal, fight efficiently, die gallantly. Specialization is for insects.  
_  
-Robert A. Heinlein
